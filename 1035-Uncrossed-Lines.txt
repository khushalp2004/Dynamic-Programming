
////1035. Uncrossed Lines
///method-1 : using memoization
int dp[501][501];
    int m, n;

    int solve(vector<int>& nums1, vector<int>& nums2, int i, int j) {
        if (i == m || j == n) {
            return 0;
        }

        if (dp[i][j] != -1) {
            return dp[i][j];
        }

        if(nums1[i]==nums2[j]){
            return dp[i][j]=1+solve(nums1,nums2,i+1,j+1);
        }else{
            return dp[i][j]=max(solve(nums1,nums2,i+1,j),solve(nums1,nums2,i,j+1));
        }
    }
    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        m = nums1.size();
        n = nums2.size();
        memset(dp, -1, sizeof(dp));
        return solve(nums1, nums2, 0, 0);
    }


///method-2 : Tabulation bottom-up dp
int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        int m = nums1.size(), n = nums2.size();

        vector<vector<int>>dp(m+1,vector<int>(n+1,0));

        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(nums1[i-1]==nums2[j-1]){
                    dp[i][j]=1+dp[i-1][j-1];
                }else{
                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[m][n];
    }

///method-3: Space Optimized method
//best method
int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        int m = nums1.size(), n = nums2.size();

        vector<int>prev(n+1,0), curr(n+1,0);

        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(nums1[i-1]==nums2[j-1]){
                    curr[j]=1+prev[j-1];
                }else{
                    curr[j]=max(prev[j],curr[j-1]);
                }
            }
            prev=curr;
        }
        return prev[n];
    }